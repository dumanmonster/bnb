import { QueryCrossChainPackageResponse, QueryReceiveSequenceResponse, QuerySendSequenceResponse } from '@bnb-chain/greenfield-cosmos-types/cosmos/crosschain/v1/query';
import { QueryInturnRelayerResponse } from '@bnb-chain/greenfield-cosmos-types/cosmos/oracle/v1/query';
import { MsgClaim } from '@bnb-chain/greenfield-cosmos-types/cosmos/oracle/v1/tx';
import { QueryParamsResponse } from '@bnb-chain/greenfield-cosmos-types/greenfield/bridge/query';
import { MsgTransferOut } from '@bnb-chain/greenfield-cosmos-types/greenfield/bridge/tx';
import { MsgMirrorBucket, MsgMirrorGroup, MsgMirrorObject } from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/tx';
import { TxResponse } from '..';
export interface ICrossChain {
    /**
     * makes a transfer from Greenfield to BSC
     */
    transferOut(msg: MsgTransferOut): Promise<TxResponse>;
    /**
     * cross-chain packages from BSC to Greenfield, used by relayers which run by validators
     */
    claims(msg: MsgClaim): Promise<TxResponse>;
    /**
     * gets the next send sequence for a channel
     */
    getChannelSendSequence(channelId: number): Promise<QuerySendSequenceResponse>;
    /**
     * gets the next receive sequence for a channel
     */
    getChannelReceiveSequence(channelId: number): Promise<QueryReceiveSequenceResponse>;
    /**
     * gets the in-turn relayer bls public key and its relay interval
     */
    getInturnRelayer(): Promise<QueryInturnRelayerResponse>;
    getCrosschainPackage(channelId: number, sequence: number): Promise<QueryCrossChainPackageResponse>;
    /**
     * mirrors the group to BSC as NFT
     */
    mirrorGroup(msg: MsgMirrorGroup): Promise<TxResponse>;
    /**
     * mirrors the bucket to BSC as NFT
     */
    mirrorBucket(msg: MsgMirrorBucket): Promise<TxResponse>;
    /**
     * mirrors the object to BSC as NFT
     */
    mirrorObject(msg: MsgMirrorObject): Promise<TxResponse>;
    getParams(): Promise<QueryParamsResponse>;
}
export declare class CrossChain implements ICrossChain {
    private basic;
    private queryClient;
    transferOut(msg: MsgTransferOut): Promise<{
        simulate: (opts: import("..").SimulateOptions) => Promise<import("..").ISimulateGasFee>;
        broadcast: (opts: import("..").BroadcastOptions) => Promise<import("@cosmjs/stargate").DeliverTxResponse>;
    }>;
    claims(msg: MsgClaim): Promise<{
        simulate: (opts: import("..").SimulateOptions) => Promise<import("..").ISimulateGasFee>;
        broadcast: (opts: import("..").BroadcastOptions) => Promise<import("@cosmjs/stargate").DeliverTxResponse>;
    }>;
    getChannelSendSequence(channelId: number): Promise<QuerySendSequenceResponse>;
    getChannelReceiveSequence(channelId: number): Promise<QueryReceiveSequenceResponse>;
    getInturnRelayer(): Promise<QueryInturnRelayerResponse>;
    getCrosschainPackage(channelId: number, sequence: number): Promise<QueryCrossChainPackageResponse>;
    mirrorGroup(msg: MsgMirrorGroup): Promise<{
        simulate: (opts: import("..").SimulateOptions) => Promise<import("..").ISimulateGasFee>;
        broadcast: (opts: import("..").BroadcastOptions) => Promise<import("@cosmjs/stargate").DeliverTxResponse>;
    }>;
    mirrorBucket(msg: MsgMirrorBucket): Promise<{
        simulate: (opts: import("..").SimulateOptions) => Promise<import("..").ISimulateGasFee>;
        broadcast: (opts: import("..").BroadcastOptions) => Promise<import("@cosmjs/stargate").DeliverTxResponse>;
    }>;
    mirrorObject(msg: MsgMirrorObject): Promise<{
        simulate: (opts: import("..").SimulateOptions) => Promise<import("..").ISimulateGasFee>;
        broadcast: (opts: import("..").BroadcastOptions) => Promise<import("@cosmjs/stargate").DeliverTxResponse>;
    }>;
    getParams(): Promise<QueryParamsResponse>;
}
